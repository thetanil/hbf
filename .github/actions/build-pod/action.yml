name: build-pod
description: Build stripped and unstripped binaries for a single pod

inputs:
  pod-name:
    description: Name of the pod (e.g., "base", "test")
    required: true
  tag:
    description: Version tag for naming assets
    required: true
  artifact-name:
    description: Name for uploaded artifacts
    required: true
  run-tests:
    description: Whether to run tests after building (default false)
    required: false
    default: 'false'
  run-smoke-test:
    description: Whether to run smoke test on built binary (default false)
    required: false
    default: 'false'
  run-lint:
    description: Whether to run lint checks (default false)
    required: false
    default: 'false'

runs:
  using: composite
  steps:
    - name: Set up Bazelisk
      uses: bazelbuild/setup-bazelisk@v3

    - name: Install lint dependencies
      if: inputs.run-lint == 'true'
      shell: bash
      run: |
        sudo apt-get update
        sudo apt-get install -y clang-tidy-18

    - name: Cache Bazel directories
      uses: actions/cache@v4
      with:
        path: |
          ~/.cache/bazel
          ~/.cache/bazelisk
        # Cache key includes pod name to isolate per-pod builds
        # Note: Both release and debug configs share the same cache because:
        # 1. The disk cache (~/.cache/bazel/ac, cas) is shared and benefits both
        # 2. The analysis cache will be discarded once when switching configs (expected)
        # 3. Using separate keys would double cache storage with minimal benefit
        key: ${{ runner.os }}-bazel-${{ inputs.pod-name }}-${{ hashFiles('.bazelrc', 'MODULE.bazel', '**/*.bzl', '**/*.bazel', 'pods/**', 'tools/**') }}
        restore-keys: |
          ${{ runner.os }}-bazel-${{ inputs.pod-name }}-
          ${{ runner.os }}-bazel-

    - name: Build pod binaries (mode-driven)
      shell: bash
      run: |
        set -euo pipefail
        POD="${{ inputs.pod-name }}"

        # Special case: "base" pod uses //:hbf target
        if [[ "$POD" == "base" ]]; then
          TARGET_NAME="hbf"
        else
          TARGET_NAME="hbf_${POD}"
        fi

        # Release-stripped build using named config
        bazel build --config=release //:${TARGET_NAME}

        # Debug-symbols build using named config
        bazel build --config=debug //:${TARGET_NAME}

    - name: Run lint
      if: inputs.run-lint == 'true'
      shell: bash
      run: |
        echo "Running lint checks..."
        bazel run //:lint

    - name: Run tests
      if: inputs.run-tests == 'true'
      shell: bash
      run: |
        echo "Running all tests..."
        bazel test //...

    - name: Smoke test binary
      if: inputs.run-smoke-test == 'true'
      shell: bash
      run: |
        set -euo pipefail
        POD="${{ inputs.pod-name }}"

        # Determine target name
        if [[ "$POD" == "base" ]]; then
          TARGET_NAME="hbf"
        else
          TARGET_NAME="hbf_${POD}"
        fi

        # Get the debug binary path for smoke test
        BINARY_PATH=$(bazel cquery --config=debug --output=files //:${TARGET_NAME})

        echo "Running smoke test on $BINARY_PATH"
        $BINARY_PATH --help
        echo "Smoke test passed!"

    - name: Prepare assets (reproducible names)
      shell: bash
      run: |
        set -euo pipefail
        POD="${{ inputs.pod-name }}"
        TAG="${{ inputs.tag }}"
        ARCH="$(uname -m)"

        # Determine target name
        if [[ "$POD" == "base" ]]; then
          TARGET_NAME="hbf"
          ASSET_BASE="hbf"
        else
          TARGET_NAME="hbf_${POD}"
          ASSET_BASE="hbf-${POD}"
        fi

        # Asset names
        NAME_STRIPPED="${ASSET_BASE}-${TAG}-linux-${ARCH}"
        NAME_UNSTRIPPED="${ASSET_BASE}-${TAG}-linux-${ARCH}-unstripped"

        # Copy binaries from configuration-specific output directories
        # Use -L to follow symlinks and get the actual binaries from their build configs
        cp -L "$(bazel cquery --config=release --output=files //:${TARGET_NAME})" "$NAME_STRIPPED"
        cp -L "$(bazel cquery --config=debug --output=files //:${TARGET_NAME})" "$NAME_UNSTRIPPED"

        # Strip the "stripped" binary to ensure it's actually stripped
        # chmod needed because Bazel outputs are read-only
        chmod +w "$NAME_STRIPPED"
        strip "$NAME_STRIPPED"

        # Generate checksums
        sha256sum "$NAME_STRIPPED" > "$NAME_STRIPPED.sha256"
        sha256sum "$NAME_UNSTRIPPED" > "$NAME_UNSTRIPPED.sha256"

    - name: Upload build assets
      uses: actions/upload-artifact@v4
      with:
        name: ${{ inputs.artifact-name }}
        path: |
          hbf*-${{ inputs.tag }}-linux-*
        if-no-files-found: error
