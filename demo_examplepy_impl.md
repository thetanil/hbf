# HBF Python Component Implementation Guide

This guide provides step-by-step instructions for implementing the Python component (`thetanil/hbf-examplepy`) that wraps the C++ mathematical functions using pybind11.

## Prerequisites

- Repository `thetanil/hbf-examplepy` exists and is cloned locally
- Repository has the eclipse-score devcontainer configured
- The C++ component (`hbf_examplecpp`) is available at v1.0.0
- Basic understanding of Python, pybind11, and Bazel
- Access to create GitHub releases and tags

## Implementation Steps

### Step 1: Create MODULE.bazel

Create the root `MODULE.bazel` file:

```bazel
module(
    name = "hbf_examplepy",
    version = "1.0.0",
    compatibility_level = 1,
)

# Core dependencies
bazel_dep(name = "rules_python", version = "0.25.0")
bazel_dep(name = "pybind11_bazel", version = "2.11.1")

# Dependency on C++ component
bazel_dep(name = "hbf_examplecpp", version = "1.0.0")

# Python toolchain configuration
python = use_extension("@rules_python//python/extensions:python.bzl", "python")
python.toolchain(python_version = "3.11")
use_repo(python, "python_3_11")

# Development dependencies
pip = use_extension("@rules_python//python/extensions:pip.bzl", "pip")
pip.parse(
    hub_name = "pip_deps",
    python_version = "3.11",
    requirements_lock = "//:requirements_lock.txt",
)
use_repo(pip, "pip_deps")
```

### Step 2: Create Root BUILD.bazel

Create the root `BUILD.bazel` file:

```bazel
# Root BUILD file for hbf-examplepy

package(default_visibility = ["//visibility:public"])

# Re-export main Python package for easy access
alias(
    name = "hbf_math",
    actual = "//src/hbf_math:hbf_math",
)

# Documentation filegroup
filegroup(
    name = "docs",
    srcs = [
        "README.md",
        "LICENSE",
        "requirements.txt",
        "requirements_lock.txt",
    ],
)
```

### Step 3: Create WORKSPACE.bazel

Create an empty `WORKSPACE.bazel` file for bzlmod compatibility:

```bash
touch WORKSPACE.bazel
```

### Step 4: Create Python Requirements Files

Create `requirements.txt`:

```text
# Runtime dependencies - none for this simple component

# Development/testing dependencies would go here if needed
# pytest>=7.0.0
# numpy>=1.20.0
```

Create `requirements_lock.txt`:

```text
# This file is autogenerated by pip-compile with Python 3.11
# To update, run:
#
#    pip-compile requirements.txt
#
# Currently no dependencies
```

### Step 5: Create Source Directory Structure

```bash
mkdir -p src/hbf_math
mkdir -p tests
```

### Step 6: Create Python Package Init File

Create `src/hbf_math/__init__.py`:

```python
"""
HBF Math - Python bindings for C++ mathematical operations.

This package provides Python access to the HBF C++ mathematical library
through pybind11 bindings.
"""

__version__ = "1.0.0"
__author__ = "HBF Demo Team"

# Import the C++ extension module
try:
    from .math_operations import add, multiply, factorial, power
    __all__ = ['add', 'multiply', 'factorial', 'power']
except ImportError as e:
    # Provide helpful error message if C++ module is not available
    raise ImportError(
        f"Failed to import C++ math operations module: {e}\n"
        "Make sure the hbf_examplecpp component is properly built and linked."
    ) from e

# Version compatibility check
def get_version():
    """Get the version of this Python component."""
    return __version__

def get_supported_operations():
    """Get list of supported mathematical operations."""
    return __all__

# Optional: Add Python-specific utility functions
def is_operation_available(operation_name):
    """Check if a specific operation is available."""
    return operation_name in __all__
```

### Step 7: Create pybind11 Wrapper

Create `src/hbf_math/python_wrapper.cpp`:

```cpp
#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include <stdexcept>

// Include the C++ header from hbf_examplecpp
#include "math_operations.h"

namespace py = pybind11;

PYBIND11_MODULE(math_operations, m) {
    m.doc() = "HBF Math Operations - Python bindings for C++ mathematical functions";
    
    // Add module-level metadata
    m.attr("__version__") = "1.0.0";
    m.attr("__author__") = "HBF Demo Team";
    
    // Bind the add function
    m.def("add", 
          &hbf_math::add, 
          "Add two integers",
          py::arg("a"), 
          py::arg("b"),
          R"pbdoc(
              Add two integers and return the result.
              
              Args:
                  a (int): First integer
                  b (int): Second integer
                  
              Returns:
                  int: Sum of a and b
                  
              Example:
                  >>> add(2, 3)
                  5
          )pbdoc");
    
    // Bind the multiply function
    m.def("multiply", 
          &hbf_math::multiply, 
          "Multiply two integers",
          py::arg("a"), 
          py::arg("b"),
          R"pbdoc(
              Multiply two integers and return the result.
              
              Args:
                  a (int): First integer
                  b (int): Second integer
                  
              Returns:
                  int: Product of a and b
                  
              Example:
                  >>> multiply(3, 4)
                  12
          )pbdoc");
    
    // Bind the factorial function
    m.def("factorial", 
          &hbf_math::factorial, 
          "Calculate factorial of a non-negative integer",
          py::arg("n"),
          R"pbdoc(
              Calculate the factorial of a non-negative integer.
              
              Args:
                  n (int): Non-negative integer
                  
              Returns:
                  int: Factorial of n
                  
              Raises:
                  RuntimeError: If n is negative
                  
              Example:
                  >>> factorial(5)
                  120
          )pbdoc");
    
    // Bind the power function
    m.def("power", 
          &hbf_math::power, 
          "Calculate power of a number",
          py::arg("base"), 
          py::arg("exponent"),
          R"pbdoc(
              Calculate base raised to the power of exponent.
              
              Args:
                  base (float): Base number
                  exponent (int): Integer exponent
                  
              Returns:
                  float: base^exponent
                  
              Example:
                  >>> power(2.0, 3)
                  8.0
          )pbdoc");
    
    // Add module-level constants or utility functions
    m.attr("PI") = 3.14159265359;
    m.attr("E") = 2.71828182846;
    
    // Exception handling example
    py::register_exception<std::invalid_argument>(m, "InvalidArgumentError");
}
```

### Step 8: Create Source BUILD.bazel

Create `src/hbf_math/BUILD.bazel`:

```bazel
load("@pybind11_bazel//:build_defs.bzl", "pybind_extension")
load("@rules_python//python:defs.bzl", "py_library")

# pybind11 extension that wraps the C++ library
pybind_extension(
    name = "math_operations",
    srcs = ["python_wrapper.cpp"],
    deps = [
        "@hbf_examplecpp//src:math_operations",
    ],
)

# Python library that includes the extension and provides the Python API
py_library(
    name = "hbf_math",
    srcs = ["__init__.py"],
    data = [":math_operations"],
    imports = [".."],
    visibility = ["//visibility:public"],
)
```

### Step 9: Create Python Test Files

Create `tests/test_math_operations.py`:

```python
#!/usr/bin/env python3
"""
Unit tests for HBF Math Operations Python component.
Tests the Python bindings for C++ mathematical functions.
"""

import unittest
import sys
import os

# Add the source directory to Python path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'src'))

from hbf_math import math_operations
import hbf_math

class TestMathOperations(unittest.TestCase):
    """Test the C++ math operations through Python bindings."""
    
    def setUp(self):
        """Set up test fixtures before each test method."""
        pass
    
    def tearDown(self):
        """Tear down test fixtures after each test method."""
        pass
    
    def test_add_function(self):
        """Test the add function with various inputs."""
        # Test positive numbers
        self.assertEqual(math_operations.add(2, 3), 5)
        self.assertEqual(math_operations.add(10, 20), 30)
        self.assertEqual(math_operations.add(0, 5), 5)
        
        # Test negative numbers
        self.assertEqual(math_operations.add(-1, 1), 0)
        self.assertEqual(math_operations.add(-5, -3), -8)
        self.assertEqual(math_operations.add(-10, 5), -5)
        
        # Test zero
        self.assertEqual(math_operations.add(0, 0), 0)
    
    def test_multiply_function(self):
        """Test the multiply function with various inputs."""
        # Test positive numbers
        self.assertEqual(math_operations.multiply(3, 4), 12)
        self.assertEqual(math_operations.multiply(7, 8), 56)
        self.assertEqual(math_operations.multiply(1, 100), 100)
        
        # Test with zero
        self.assertEqual(math_operations.multiply(0, 5), 0)
        self.assertEqual(math_operations.multiply(10, 0), 0)
        self.assertEqual(math_operations.multiply(0, 0), 0)
        
        # Test negative numbers
        self.assertEqual(math_operations.multiply(-2, 5), -10)
        self.assertEqual(math_operations.multiply(3, -4), -12)
        self.assertEqual(math_operations.multiply(-6, -7), 42)
    
    def test_factorial_function(self):
        """Test the factorial function with valid inputs."""
        # Test basic cases
        self.assertEqual(math_operations.factorial(0), 1)
        self.assertEqual(math_operations.factorial(1), 1)
        self.assertEqual(math_operations.factorial(5), 120)
        self.assertEqual(math_operations.factorial(6), 720)
        
        # Test larger values
        self.assertEqual(math_operations.factorial(10), 3628800)
    
    def test_factorial_negative_input(self):
        """Test factorial function error handling for negative inputs."""
        with self.assertRaises(RuntimeError):
            math_operations.factorial(-1)
        
        with self.assertRaises(RuntimeError):
            math_operations.factorial(-5)
    
    def test_power_function(self):
        """Test the power function with various inputs."""
        # Test basic cases
        self.assertAlmostEqual(math_operations.power(2.0, 0), 1.0, places=5)
        self.assertAlmostEqual(math_operations.power(2.0, 3), 8.0, places=5)
        self.assertAlmostEqual(math_operations.power(5.0, 2), 25.0, places=5)
        
        # Test negative exponents
        self.assertAlmostEqual(math_operations.power(2.0, -1), 0.5, places=5)
        self.assertAlmostEqual(math_operations.power(4.0, -2), 0.0625, places=5)
        
        # Test zero base
        self.assertAlmostEqual(math_operations.power(0.0, 5), 0.0, places=5)
        self.assertAlmostEqual(math_operations.power(0.0, 0), 1.0, places=5)
    
    def test_type_conversions(self):
        """Test that type conversions work correctly."""
        # Integer operations should return integers
        self.assertIsInstance(math_operations.add(1, 2), int)
        self.assertIsInstance(math_operations.multiply(3, 4), int)
        self.assertIsInstance(math_operations.factorial(3), int)
        
        # Power should return float
        self.assertIsInstance(math_operations.power(2.5, 2), float)
    
    def test_python_package_functions(self):
        """Test Python package-level functions."""
        # Test version function
        version = hbf_math.get_version()
        self.assertEqual(version, "1.0.0")
        
        # Test supported operations
        operations = hbf_math.get_supported_operations()
        expected_ops = ['add', 'multiply', 'factorial', 'power']
        self.assertEqual(set(operations), set(expected_ops))
        
        # Test operation availability
        self.assertTrue(hbf_math.is_operation_available('add'))
        self.assertTrue(hbf_math.is_operation_available('factorial'))
        self.assertFalse(hbf_math.is_operation_available('nonexistent'))
    
    def test_module_attributes(self):
        """Test that module attributes are correctly set."""
        # Test module-level constants
        self.assertAlmostEqual(math_operations.PI, 3.14159265359, places=5)
        self.assertAlmostEqual(math_operations.E, 2.71828182846, places=5)
        
        # Test version and author
        self.assertEqual(math_operations.__version__, "1.0.0")
        self.assertEqual(math_operations.__author__, "HBF Demo Team")

class TestIntegrationScenarios(unittest.TestCase):
    """Test integration scenarios combining multiple functions."""
    
    def test_combined_operations(self):
        """Test using multiple operations together."""
        # Calculate factorial then add
        fact_5 = math_operations.factorial(5)
        result = math_operations.add(fact_5, 10)
        self.assertEqual(result, 130)  # 120 + 10
        
        # Calculate power then multiply
        power_result = math_operations.power(3.0, 2)
        mult_result = math_operations.multiply(int(power_result), 4)
        self.assertEqual(mult_result, 36)  # 9 * 4
    
    def test_error_propagation(self):
        """Test that C++ exceptions are properly converted to Python exceptions."""
        # This should raise a RuntimeError (converted from std::invalid_argument)
        with self.assertRaises(RuntimeError) as context:
            math_operations.factorial(-3)
        
        # Check that error message is meaningful
        error_message = str(context.exception)
        self.assertIn("negative", error_message.lower())

if __name__ == '__main__':
    print("Running HBF Python Component Tests...")
    unittest.main(verbosity=2)
```

### Step 10: Create Integration Test

Create `tests/test_integration.py`:

```python
#!/usr/bin/env python3
"""
Integration tests specifically for validating C++/Python integration.
These tests focus on the boundary between languages.
"""

import unittest
import sys
import os

# Add the source directory to Python path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'src'))

from hbf_math import math_operations

class TestCppPythonIntegration(unittest.TestCase):
    """Test the integration between C++ backend and Python frontend."""
    
    def test_memory_management(self):
        """Test that memory is properly managed across language boundary."""
        # Perform many operations to test for memory leaks
        for i in range(1000):
            result = math_operations.add(i, i)
            self.assertEqual(result, 2 * i)
    
    def test_large_number_handling(self):
        """Test handling of large numbers across C++/Python boundary."""
        # Test large integers
        large_a = 2**30
        large_b = 2**30
        result = math_operations.add(large_a, large_b)
        self.assertEqual(result, 2**31)
        
        # Test large factorial (within reasonable limits)
        result = math_operations.factorial(20)
        expected = 2432902008176640000
        self.assertEqual(result, expected)
    
    def test_floating_point_precision(self):
        """Test floating point precision across language boundary."""
        # Test that floating point operations maintain precision
        result = math_operations.power(1.23456789, 2)
        expected = 1.23456789 ** 2
        self.assertAlmostEqual(result, expected, places=10)
    
    def test_exception_boundary(self):
        """Test exception handling across C++/Python boundary."""
        # Test that C++ exceptions become Python exceptions
        with self.assertRaises(RuntimeError):
            math_operations.factorial(-1)
        
        # Test that the exception preserves meaningful information
        try:
            math_operations.factorial(-5)
            self.fail("Expected RuntimeError")
        except RuntimeError as e:
            error_msg = str(e)
            # Should contain information about the invalid input
            self.assertTrue(len(error_msg) > 0)
    
    def test_parameter_validation(self):
        """Test parameter validation and type conversion."""
        # Test automatic type conversion from Python to C++
        self.assertEqual(math_operations.add(1.0, 2.0), 3)  # float to int
        self.assertEqual(math_operations.add(True, False), 1)  # bool to int
        
        # Test that power accepts float base
        result = math_operations.power(2.5, 3)
        self.assertAlmostEqual(result, 15.625, places=5)

if __name__ == '__main__':
    print("Running C++/Python Integration Tests...")
    unittest.main(verbosity=2)
```

### Step 11: Create Test BUILD.bazel

Create `tests/BUILD.bazel`:

```bazel
load("@rules_python//python:defs.bzl", "py_test")

py_test(
    name = "test_math_operations",
    srcs = ["test_math_operations.py"],
    deps = [
        "//src/hbf_math:hbf_math",
    ],
    python_version = "PY3",
    main = "test_math_operations.py",
)

py_test(
    name = "test_integration",
    srcs = ["test_integration.py"],
    deps = [
        "//src/hbf_math:hbf_math",
    ],
    python_version = "PY3",
    main = "test_integration.py",
)

# Test specifically for v1.1.0 GCD functionality (will be added later)
py_test(
    name = "test_gcd_functionality",
    srcs = ["test_gcd_functionality.py"],
    deps = [
        "//src/hbf_math:hbf_math",
    ],
    python_version = "PY3",
    main = "test_gcd_functionality.py",
    # This test will fail until both components are at v1.1.0
    tags = ["manual"],  # Don't run by default initially
)
```

### Step 12: Create .bazelrc Configuration

Create `.bazelrc`:

```bash
# Build configuration for Python component
build --enable_bzlmod
build --experimental_enable_bzlmod

# Python configuration
build --python_top=@python_3_11//:bin/python

# Test configuration
test --test_output=errors
test --test_verbose_timeout_warnings
test --python_top=@python_3_11//:bin/python

# Performance optimizations
build --jobs=auto

# Debugging options (uncomment as needed)
# build --verbose_failures
# test --test_output=all
```

### Step 13: Create README.md

Create `README.md`:

```markdown
# HBF Example Python Component

Python bindings for the HBF C++ mathematical library using pybind11. This component demonstrates cross-language integration in the HBF ecosystem.

## Overview

This component provides Python access to C++ mathematical functions through pybind11 bindings. It demonstrates:

- Cross-language interoperability (C++ ↔ Python)
- Bazel module (bzlmod) integration for mixed-language projects
- pybind11 integration with Bazel
- Comprehensive testing across language boundaries
- Semantic versioning for multi-language components

## Functions Provided

### v1.0.0 Functions

All functions from `hbf_examplecpp` are available through Python bindings:

- `add(a: int, b: int) -> int` - Add two integers
- `multiply(a: int, b: int) -> int` - Multiply two integers
- `factorial(n: int) -> int` - Calculate factorial (raises RuntimeError for negative input)
- `power(base: float, exponent: int) -> float` - Calculate power

### v1.1.0 Functions (Added Later)

- `gcd(a: int, b: int) -> int` - Calculate greatest common divisor

## Building

### Prerequisites

- Bazel 6.0+ with bzlmod support
- Python 3.11+
- pybind11 (handled by Bazel)
- hbf_examplecpp component available

### Build Commands

```bash
# Build the Python package
bazel build //src/hbf_math:hbf_math

# Build everything
bazel build //...

# Run tests
bazel test //...

# Run specific test
bazel test //tests:test_math_operations --test_output=all
```

## Usage

### In Python Code

```python
from hbf_math import math_operations

# Basic operations
result = math_operations.add(5, 3)        # Returns 8
result = math_operations.multiply(4, 6)   # Returns 24
result = math_operations.factorial(5)     # Returns 120
result = math_operations.power(2.0, 10)   # Returns 1024.0

# Error handling
try:
    result = math_operations.factorial(-1)
except RuntimeError as e:
    print(f"Error: {e}")
```

### In Other Bazel Targets

Add to your `MODULE.bazel`:

```bazel
bazel_dep(name = "hbf_examplepy", version = "1.0.0")
```

Use in your BUILD.bazel:

```bazel
py_binary(
    name = "my_app",
    srcs = ["main.py"],
    deps = ["@hbf_examplepy//src/hbf_math:hbf_math"],
)
```

## Package Structure

```
src/hbf_math/
├── __init__.py           # Python package interface
├── python_wrapper.cpp    # pybind11 C++ bindings
└── BUILD.bazel           # Bazel build rules

tests/
├── test_math_operations.py    # Unit tests for all functions
├── test_integration.py        # Integration tests
└── BUILD.bazel               # Test build rules
```

## Testing

The component includes comprehensive tests:

### Unit Tests (`test_math_operations.py`)
- Function correctness across all operations
- Error handling and exception propagation
- Type conversion validation
- Package-level functionality

### Integration Tests (`test_integration.py`)
- Memory management across language boundary
- Large number handling
- Floating point precision
- Exception translation from C++ to Python

### Running Tests

```bash
# Run all tests
bazel test //...

# Run specific test suite
bazel test //tests:test_math_operations

# Run with verbose output
bazel test //tests:test_integration --test_output=all
```

## Dependencies

- **hbf_examplecpp**: The C++ mathematical library being wrapped
- **pybind11**: C++/Python binding library
- **rules_python**: Bazel rules for Python
- **rules_cc**: Bazel rules for C++ (transitive dependency)

## Versioning

This component follows semantic versioning and tracks the C++ component:

- **v1.0.0**: Initial release with basic mathematical operations
- **v1.1.0**: Added GCD function (requires hbf_examplecpp v1.1.0)

## Error Handling

C++ exceptions are automatically translated to Python exceptions:

- `std::invalid_argument` → `RuntimeError`
- Error messages are preserved across the language boundary
- Stack traces are available for debugging

## Performance Notes

- Function calls have minimal overhead due to pybind11 optimization
- Large number operations maintain precision
- Memory management is automatic (no manual cleanup required)

## Integration

This component integrates with:

- `hbf_examplecpp` - Provides the underlying C++ implementation
- `hbf` meta-repository - Integration testing and version coordination

## License

MIT License - see LICENSE file for details.
```

### Step 14: Create LICENSE File

Create `LICENSE` (same as C++ component):

```text
MIT License

Copyright (c) 2025 HBF Demo

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

### Step 15: Create GitHub Workflow for CI

Create `.github/workflows/ci.yml`:

```yaml
name: Python Component CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  release:
    types: [published]

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup Bazel
      uses: bazelbuild/setup-bazelisk@v2
    
    - name: Cache Bazel
      uses: actions/cache@v3
      with:
        path: |
          ~/.cache/bazel
        key: ${{ runner.os }}-bazel-py-${{ hashFiles('.bazelversion', '.bazelrc', 'MODULE.bazel') }}
        restore-keys: |
          ${{ runner.os }}-bazel-py-
    
    - name: Build Python package
      run: bazel build //src/hbf_math:hbf_math
    
    - name: Build all targets
      run: bazel build //...
    
    - name: Run unit tests
      run: bazel test //tests:test_math_operations --test_output=errors
    
    - name: Run integration tests
      run: bazel test //tests:test_integration --test_output=errors
    
    - name: Test GCD functionality (v1.1.0) - Optional
      run: |
        # This will pass only when C++ component is at v1.1.0
        bazel test //tests:test_gcd_functionality || echo "GCD test failed - C++ component not yet at v1.1.0"
    
    - name: Validate Python imports
      run: |
        # Test that the module can be imported correctly
        python3 -c "
        import sys
        sys.path.insert(0, 'bazel-bin/src')
        try:
            import hbf_math
            print('✅ Python package imports successfully')
            print(f'Version: {hbf_math.get_version()}')
            print(f'Operations: {hbf_math.get_supported_operations()}')
        except ImportError as e:
            print(f'❌ Import failed: {e}')
            sys.exit(1)
        "
    
    - name: Generate test report
      run: |
        echo "## Test Report" >> $GITHUB_STEP_SUMMARY
        echo "- Unit tests: ✅ Passed" >> $GITHUB_STEP_SUMMARY
        echo "- Integration tests: ✅ Passed" >> $GITHUB_STEP_SUMMARY
        echo "- Python imports: ✅ Working" >> $GITHUB_STEP_SUMMARY

  notify-integration:
    needs: build-and-test
    runs-on: ubuntu-latest
    if: github.event_name == 'release'
    
    steps:
    - name: Notify HBF meta-repo of new version
      run: |
        VERSION="${{ github.event.release.tag_name }}"
        echo "Notifying meta-repo of new version: $VERSION"
        
        # Extract version number (remove 'v' prefix if present)
        VERSION_NUMBER="${VERSION#v}"
        
        curl -X POST \
          -H "Authorization: token ${{ secrets.META_REPO_TOKEN }}" \
          -H "Accept: application/vnd.github.v3+json" \
          https://api.github.com/repos/thetanil/hbf/dispatches \
          -d '{
            "event_type": "component-update",
            "client_payload": {
              "component": "hbf_examplepy",
              "version": "'$VERSION_NUMBER'",
              "repository": "thetanil/hbf-examplepy",
              "release_url": "${{ github.event.release.html_url }}"
            }
          }'
```

### Step 16: Test the v1.0.0 Implementation

```bash
# Build everything
bazel build //...

# Run all tests
bazel test //...

# Test specific components
bazel test //tests:test_math_operations --test_output=all
bazel test //tests:test_integration --test_output=all

# Verify the Python package builds
bazel build //src/hbf_math:hbf_math
```

### Step 17: Create Release v1.0.0

```bash
# Ensure everything is committed
git add .
git commit -m "Initial implementation of Python bindings v1.0.0"
git push origin main

# Create and push tag
git tag v1.0.0
git push origin v1.0.0
```

## Preparing for v1.1.0 Update (GCD Function)

When ready to demonstrate the dependency update scenario:

### Step 18: Create GCD Test File (v1.1.0)

Create `tests/test_gcd_functionality.py`:

```python
#!/usr/bin/env python3
"""
Tests for GCD functionality added in v1.1.0.
This test will fail until hbf_examplecpp is upgraded to v1.1.0.
"""

import unittest
import sys
import os

# Add the source directory to Python path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'src'))

from hbf_math import math_operations

class TestGCDFunctionality(unittest.TestCase):
    """Test the GCD function added in v1.1.0."""
    
    def test_gcd_basic_cases(self):
        """Test basic GCD calculations."""
        # Test basic GCD cases
        self.assertEqual(math_operations.gcd(48, 18), 6)
        self.assertEqual(math_operations.gcd(17, 13), 1)  # Coprime
        self.assertEqual(math_operations.gcd(100, 25), 25)
        self.assertEqual(math_operations.gcd(7, 7), 7)    # Same numbers
    
    def test_gcd_with_zero(self):
        """Test GCD with zero values."""
        self.assertEqual(math_operations.gcd(25, 0), 25)
        self.assertEqual(math_operations.gcd(0, 30), 30)
        self.assertEqual(math_operations.gcd(0, 0), 0)
    
    def test_gcd_with_negatives(self):
        """Test GCD with negative numbers."""
        self.assertEqual(math_operations.gcd(-12, 8), 4)
        self.assertEqual(math_operations.gcd(12, -8), 4)
        self.assertEqual(math_operations.gcd(-12, -8), 4)
    
    def test_gcd_large_numbers(self):
        """Test GCD with large numbers."""
        self.assertEqual(math_operations.gcd(1071, 462), 21)
        self.assertEqual(math_operations.gcd(270, 192), 6)
    
    def test_gcd_integration_with_other_functions(self):
        """Test GCD in combination with other functions."""
        # Calculate GCD then use in other operations
        a, b = 24, 36
        gcd_result = math_operations.gcd(a, b)
        self.assertEqual(gcd_result, 12)
        
        # Use GCD result in factorial
        if gcd_result <= 10:  # Keep factorial reasonable
            fact_result = math_operations.factorial(gcd_result)
            self.assertEqual(fact_result, 479001600)  # 12!
        
        # Use GCD result in power calculation
        power_result = math_operations.power(float(gcd_result), 2)
        self.assertAlmostEqual(power_result, 144.0, places=5)

if __name__ == '__main__':
    print("Running GCD Functionality Tests (v1.1.0)...")
    unittest.main(verbosity=2)
```

### Step 19: Update Python Wrapper for GCD (v1.1.0)

Update `src/hbf_math/python_wrapper.cpp` to add GCD binding:

```cpp
// Add this binding to the existing PYBIND11_MODULE function:

// Bind the GCD function (added in v1.1.0)
m.def("gcd", 
      &hbf_math::gcd, 
      "Calculate greatest common divisor of two integers",
      py::arg("a"), 
      py::arg("b"),
      R"pbdoc(
          Calculate the greatest common divisor (GCD) of two integers.
          
          Args:
              a (int): First integer
              b (int): Second integer
              
          Returns:
              int: Greatest common divisor of a and b
              
          Example:
              >>> gcd(48, 18)
              6
              >>> gcd(17, 13)
              1
      )pbdoc");
```

### Step 20: Update Python Package Init (v1.1.0)

Update `src/hbf_math/__init__.py`:

```python
# Update version
__version__ = "1.1.0"

# Import the C++ extension module including new GCD function
try:
    from .math_operations import add, multiply, factorial, power, gcd
    __all__ = ['add', 'multiply', 'factorial', 'power', 'gcd']
except ImportError as e:
    # Provide helpful error message if C++ module is not available
    raise ImportError(
        f"Failed to import C++ math operations module: {e}\n"
        "Make sure the hbf_examplecpp component is properly built and linked."
    ) from e
```

### Step 21: Update Dependencies for v1.1.0

Update `MODULE.bazel`:

```bazel
module(
    name = "hbf_examplepy",
    version = "1.1.0",  # Bump version
    compatibility_level = 1,
)

# Dependencies remain the same except C++ component version
bazel_dep(name = "rules_python", version = "0.25.0")
bazel_dep(name = "pybind11_bazel", version = "2.11.1")

# Update dependency on C++ component to v1.1.0
bazel_dep(name = "hbf_examplecpp", version = "1.1.0")

# Python toolchain remains the same
python = use_extension("@rules_python//python/extensions:python.bzl", "python")
python.toolchain(python_version = "3.11")
use_repo(python, "python_3_11")
```

### Step 22: Test v1.1.0 Implementation

```bash
# Build everything with new GCD function
bazel build //...

# Run all tests including GCD tests
bazel test //...

# Test GCD functionality specifically
bazel test //tests:test_gcd_functionality --test_output=all
```

### Step 23: Release v1.1.0

```bash
# Commit changes
git add .
git commit -m "Add GCD function support for v1.1.0"
git push origin main

# Create and push tag
git tag v1.1.0
git push origin v1.1.0
```

## Validation Checklist

### v1.0.0 Checklist
- [ ] MODULE.bazel configured with correct dependencies
- [ ] pybind11 wrapper compiles and links successfully
- [ ] All Python tests pass
- [ ] Python package can be imported
- [ ] C++ functions accessible from Python
- [ ] Error handling works across language boundary
- [ ] GitHub CI workflow runs successfully
- [ ] Documentation is complete

### v1.1.0 Checklist
- [ ] GCD function added to wrapper and package
- [ ] GCD tests added and passing
- [ ] Version bumped to 1.1.0 in all relevant files
- [ ] Dependency on hbf_examplecpp v1.1.0 correctly specified
- [ ] All existing functionality still works
- [ ] New functionality tested thoroughly
- [ ] Integration with other functions validated

## Integration Notes

- This component wraps `hbf_examplecpp` using pybind11
- Version updates must be coordinated with the C++ component
- The component is consumed by the `hbf` meta-repository for integration testing
- Automatic notifications are sent to meta-repo on new releases

This implementation provides a comprehensive Python wrapper that demonstrates cross-language integration capabilities in the HBF system.
