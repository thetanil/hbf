#!/bin/bash
# inject_content.sh - Convert static files to SQL INSERT statements
#
# Usage: inject_content.sh <static_dir> <output_sql>
#
# Walks through static directory and generates SQL INSERT statements
# that add files to the nodes table with type='static' or 'script'.

set -e

if [ $# -ne 2 ]; then
	echo "Usage: $0 <static_dir> <output_sql>" >&2
	exit 1
fi

STATIC_DIR="$1"
OUTPUT_SQL="$2"

if [ ! -d "$STATIC_DIR" ]; then
	echo "Error: Directory '$STATIC_DIR' not found" >&2
	exit 1
fi

# Start SQL file
cat > "$OUTPUT_SQL" << 'EOF'
-- Static content for HBF
-- Generated by tools/inject_content.sh
-- DO NOT EDIT MANUALLY

EOF

# Process each file
find "$STATIC_DIR" -type f | sort | while read -r file; do
	# Get relative path from static dir
	rel_path="${file#$STATIC_DIR/}"

	# Determine type and name based on file
	if [[ "$rel_path" == "server.js" ]]; then
		type="js"
		name="server.js"
	elif [[ "$rel_path" == "lib/router.js" ]]; then
		type="js"
		name="router.js"
	elif [[ "$rel_path" == www/* ]]; then
		# Static web content
		type="static"
		# Remove www/ prefix for cleaner paths (www/index.html -> index.html)
		name="${rel_path#www/}"
	else
		type="static"
		name="$rel_path"
	fi

	# Read file content and create proper JSON object
	python3 - "$file" "$type" "$name" >> "$OUTPUT_SQL" << 'PYTHON_SCRIPT'
import sys, json
with open(sys.argv[1], 'r') as f:
    content = f.read()
body = json.dumps({'name': sys.argv[3], 'content': content})
# Escape single quotes for SQL by doubling them
body_escaped = body.replace("'", "''")
print(f"INSERT INTO nodes (type, body) VALUES ('{sys.argv[2]}', '{body_escaped}');")
PYTHON_SCRIPT
done

echo "Generated $OUTPUT_SQL with $(grep -c '^INSERT' "$OUTPUT_SQL") inserts"
